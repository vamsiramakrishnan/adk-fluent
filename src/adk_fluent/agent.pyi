"""AUTO-GENERATED by adk-fluent generator -- do not edit manually
Generated from google-adk 1.25.0
Timestamp: 2026-02-20T10:12:25.841828+00:00"""

from collections.abc import AsyncIterator, Awaitable
from collections.abc import Callable
from typing import Any, Self
from typing import Literal

from google.adk.agents.base_agent import BaseAgent as _ADK_BaseAgent
from google.adk.agents.llm_agent import LlmAgent
from google.adk.agents.readonly_context import ReadonlyContext
from google.adk.code_executors.base_code_executor import BaseCodeExecutor
from google.adk.models.base_llm import BaseLlm
from google.adk.planners.base_planner import BasePlanner
from google.adk.tools.base_tool import BaseTool
from google.adk.tools.base_toolset import BaseToolset
from google.genai.types import Content
from google.genai.types import File
from google.genai.types import GenerateContentConfig
from google.genai.types import Part
from pydantic import BaseModel

from adk_fluent._base import BuilderBase

class BaseAgent(BuilderBase):
    """Base class for all agents in Agent Development Kit."""
    def __init__(self, name: str) -> None: ...
    def describe(self, value: str) -> Self: ...
    def after_agent(self, *fns: Callable[..., Any]) -> Self: ...
    def after_agent_if(self, condition: bool, fn: Callable[..., Any]) -> Self: ...
    def before_agent(self, *fns: Callable[..., Any]) -> Self: ...
    def before_agent_if(self, condition: bool, fn: Callable[..., Any]) -> Self: ...
    def sub_agents(self, value: list[_ADK_BaseAgent]) -> Self: ...
    def sub_agent(self, value: _ADK_BaseAgent) -> Self: ...
    def build(self) -> _ADK_BaseAgent: ...


class Agent(BuilderBase):
    """LLM-based Agent."""
    def __init__(self, name: str, model: str | None = None) -> None: ...
    def describe(self, value: str) -> Self: ...
    def global_instruct(self, value: str | Callable[[ReadonlyContext], str | Awaitable[str]]) -> Self: ...
    def history(self, value: Literal['default', 'none']) -> Self: ...
    def include_history(self, value: Literal['default', 'none']) -> Self: ...
    def instruct(self, value: str | Callable[[ReadonlyContext], str | Awaitable[str]]) -> Self: ...
    def outputs(self, value: str | None) -> Self: ...
    def static(self, value: Content | str | File | Part | list[str | File | Part] | None) -> Self: ...
    def static_instruct(self, value: Content | str | File | Part | list[str | File | Part] | None) -> Self: ...
    def after_agent(self, *fns: Callable[..., Any]) -> Self: ...
    def after_agent_if(self, condition: bool, fn: Callable[..., Any]) -> Self: ...
    def after_model(self, *fns: Callable[..., Any]) -> Self: ...
    def after_model_if(self, condition: bool, fn: Callable[..., Any]) -> Self: ...
    def after_tool(self, *fns: Callable[..., Any]) -> Self: ...
    def after_tool_if(self, condition: bool, fn: Callable[..., Any]) -> Self: ...
    def before_agent(self, *fns: Callable[..., Any]) -> Self: ...
    def before_agent_if(self, condition: bool, fn: Callable[..., Any]) -> Self: ...
    def before_model(self, *fns: Callable[..., Any]) -> Self: ...
    def before_model_if(self, condition: bool, fn: Callable[..., Any]) -> Self: ...
    def before_tool(self, *fns: Callable[..., Any]) -> Self: ...
    def before_tool_if(self, condition: bool, fn: Callable[..., Any]) -> Self: ...
    def on_model_error(self, *fns: Callable[..., Any]) -> Self: ...
    def on_model_error_if(self, condition: bool, fn: Callable[..., Any]) -> Self: ...
    def on_tool_error(self, *fns: Callable[..., Any]) -> Self: ...
    def on_tool_error_if(self, condition: bool, fn: Callable[..., Any]) -> Self: ...
    def sub_agents(self, value: list[_ADK_BaseAgent]) -> Self: ...
    def model(self, value: str | BaseLlm) -> Self: ...
    def tools(self, value: list[Callable[..., Any] | BaseTool | BaseToolset]) -> Self: ...
    def generate_content_config(self, value: GenerateContentConfig | None) -> Self: ...
    def disallow_transfer_to_parent(self, value: bool) -> Self: ...
    def disallow_transfer_to_peers(self, value: bool) -> Self: ...
    def input_schema(self, value: type[BaseModel] | None) -> Self: ...
    def output_schema(self, value: type[BaseModel] | None) -> Self: ...
    def planner(self, value: BasePlanner | None) -> Self: ...
    def code_executor(self, value: BaseCodeExecutor | None) -> Self: ...
    def sub_agent(self, value: _ADK_BaseAgent) -> Self: ...
    def tool(self, fn_or_tool: Any, *, require_confirmation: bool = False) -> Self: ...
    def guardrail(self, fn: Callable[..., Any]) -> Self: ...
    def ask(self, prompt: str) -> str: ...
    async def ask_async(self, prompt: str) -> str: ...
    async def stream(self, prompt: str) -> AsyncIterator[str]: ...
    def test(self, prompt: str, *, contains: str | None = None, matches: str | None = None, equals: str | None = None) -> Self: ...
    def session(self) -> Any: ...
    def map(self, prompts: list[str], *, concurrency: int = 5) -> list[str]: ...
    async def map_async(self, prompts: list[str], *, concurrency: int = 5) -> list[str]: ...
    async def events(self, prompt: str) -> AsyncIterator[Any]: ...
    def context(self, spec: Any) -> Self: ...
    def show(self) -> Self: ...
    def hide(self) -> Self: ...
    def memory(self, mode: str = 'preload') -> Self: ...
    def memory_auto_save(self) -> Self: ...
    def delegate(self, agent: Any) -> Self: ...
    def isolate(self) -> Self: ...
    def to_ir(self) -> Any: ...
    def build(self) -> LlmAgent: ...
