"""AUTO-GENERATED by adk-fluent generator -- do not edit manually
Generated from google-adk 1.25.0
Timestamp: 2026-02-20T05:35:25.156049+00:00"""

from adk_fluent._base import BuilderBase
from collections.abc import AsyncGenerator, Callable
from google.adk.agents.base_agent import BaseAgent as _ADK_BaseAgent
from google.adk.agents.llm_agent import LlmAgent
from typing import Any, Self

class BaseAgent(BuilderBase):
    """Base class for all agents in Agent Development Kit."""
    _ALIASES: dict[str, str] = {'describe': 'description'}
    _CALLBACK_ALIASES: dict[str, str] = {'after_agent': 'after_agent_callback', 'before_agent': 'before_agent_callback'}
    _ADDITIVE_FIELDS: set[str] = {'after_agent_callback', 'before_agent_callback'}
    _ADK_TARGET_CLASS = _ADK_BaseAgent
    def __init__(self, name: str) -> None: ...
    def describe(self, value: str) -> Self: ...
    def after_agent(self, *fns: Callable) -> Self: ...
    def after_agent_if(self, condition: bool, fn: Callable) -> Self: ...
    def before_agent(self, *fns: Callable) -> Self: ...
    def before_agent_if(self, condition: bool, fn: Callable) -> Self: ...
    def sub_agents(self, value: list[BaseAgent]) -> Self: ...
    def build(self) -> _ADK_BaseAgent: ...


class Agent(BuilderBase):
    """LLM-based Agent."""
    _ALIASES: dict[str, str] = {'describe': 'description', 'global_instruct': 'global_instruction', 'history': 'include_contents', 'include_history': 'include_contents', 'instruct': 'instruction', 'outputs': 'output_key', 'static': 'static_instruction'}
    _CALLBACK_ALIASES: dict[str, str] = {'after_agent': 'after_agent_callback', 'after_model': 'after_model_callback', 'after_tool': 'after_tool_callback', 'before_agent': 'before_agent_callback', 'before_model': 'before_model_callback', 'before_tool': 'before_tool_callback', 'on_model_error': 'on_model_error_callback', 'on_tool_error': 'on_tool_error_callback'}
    _ADDITIVE_FIELDS: set[str] = {'after_model_callback', 'before_model_callback', 'before_tool_callback', 'on_model_error_callback', 'after_tool_callback', 'after_agent_callback', 'on_tool_error_callback', 'before_agent_callback'}
    _ADK_TARGET_CLASS = LlmAgent
    def __init__(self, name: str, model: str | None = None) -> None: ...
    def describe(self, value: str) -> Self: ...
    def global_instruct(self, value: Union[str, Callable[ReadonlyContext, Union[str, Awaitable[str]]]]) -> Self: ...
    def history(self, value: Literal[default, none]) -> Self: ...
    def include_history(self, value: Literal[default, none]) -> Self: ...
    def instruct(self, value: Union[str, Callable[ReadonlyContext, Union[str, Awaitable[str]]]]) -> Self: ...
    def outputs(self, value: Union[str, NoneType]) -> Self: ...
    def static(self, value: Union[Content, str, Image, File, Part, list[Union[str, Image, File, Part]], NoneType]) -> Self: ...
    def after_agent(self, *fns: Callable) -> Self: ...
    def after_agent_if(self, condition: bool, fn: Callable) -> Self: ...
    def after_model(self, *fns: Callable) -> Self: ...
    def after_model_if(self, condition: bool, fn: Callable) -> Self: ...
    def after_tool(self, *fns: Callable) -> Self: ...
    def after_tool_if(self, condition: bool, fn: Callable) -> Self: ...
    def before_agent(self, *fns: Callable) -> Self: ...
    def before_agent_if(self, condition: bool, fn: Callable) -> Self: ...
    def before_model(self, *fns: Callable) -> Self: ...
    def before_model_if(self, condition: bool, fn: Callable) -> Self: ...
    def before_tool(self, *fns: Callable) -> Self: ...
    def before_tool_if(self, condition: bool, fn: Callable) -> Self: ...
    def on_model_error(self, *fns: Callable) -> Self: ...
    def on_model_error_if(self, condition: bool, fn: Callable) -> Self: ...
    def on_tool_error(self, *fns: Callable) -> Self: ...
    def on_tool_error_if(self, condition: bool, fn: Callable) -> Self: ...
    def sub_agents(self, value: list[BaseAgent]) -> Self: ...
    def model(self, value: Union[str, BaseLlm]) -> Self: ...
    def tools(self, value: list[Union[Callable, BaseTool, BaseToolset]]) -> Self: ...
    def generate_content_config(self, value: Union[GenerateContentConfig, NoneType]) -> Self: ...
    def disallow_transfer_to_parent(self, value: bool) -> Self: ...
    def disallow_transfer_to_peers(self, value: bool) -> Self: ...
    def input_schema(self, value: Union[type[BaseModel], NoneType]) -> Self: ...
    def output_schema(self, value: Union[type[BaseModel], NoneType]) -> Self: ...
    def planner(self, value: Union[BasePlanner, NoneType]) -> Self: ...
    def code_executor(self, value: Union[BaseCodeExecutor, NoneType]) -> Self: ...
    def apply(self, stack: MiddlewareStack) -> Self: ...
    def sub_agent(self, agent: BaseAgent | AgentBuilder) -> Self: ...
    def member(self, agent: BaseAgent | AgentBuilder) -> Self: ...
    def delegate(self, agent) -> Self: ...
    def tool(self, fn_or_tool, *, require_confirmation: bool = False) -> Self: ...
    def guardrail(self, fn: Callable) -> Self: ...
    def ask(self, prompt: str) -> str: ...
    async def ask_async(self, prompt: str) -> str: ...
    async def stream(self, prompt: str) -> AsyncIterator[str]: ...
    def test(self, prompt: str, *, contains: str | None = None, matches: str | None = None, equals: str | None = None) -> Self: ...
    def session(self): ...
    def map(self, prompts: list[str], *, concurrency: int = 5) -> list[str]: ...
    async def map_async(self, prompts: list[str], *, concurrency: int = 5) -> list[str]: ...
    async def events(self, prompt: str) -> AsyncIterator: ...
    def context(self, spec: Any) -> Self: ...
    def show(self) -> Self: ...
    def hide(self) -> Self: ...
    def memory(self, mode: str = 'preload') -> Self: ...
    def memory_auto_save(self) -> Self: ...
    def isolate(self) -> Self: ...
    def to_ir(self): ...
    def build(self) -> LlmAgent: ...
