"""AUTO-GENERATED by adk-fluent generator -- do not edit manually
Generated from google-adk 1.25.0
Timestamp: 2026-02-20T08:01:14.455594+00:00"""

from collections.abc import AsyncIterator, Awaitable
from collections.abc import Callable
from typing import Any, Self
from typing import Literal

from google.adk.agents.active_streaming_tool import BaseModel
from google.adk.agents.base_agent import BaseAgent
from google.adk.agents.base_agent import BaseAgent as _ADK_BaseAgent
from google.adk.agents.llm_agent import LlmAgent
from google.adk.agents.readonly_context import ReadonlyContext
from google.adk.code_executors.base_code_executor import BaseCodeExecutor
from google.adk.models.base_llm import BaseLlm
from google.adk.planners.base_planner import BasePlanner
from google.adk.tools.base_tool import BaseTool
from google.adk.tools.base_toolset import BaseToolset
from google.genai.types import Content
from google.genai.types import File
from google.genai.types import GenerateContentConfig
from google.genai.types import Part

from adk_fluent._base import BuilderBase

class BaseAgent(BuilderBase):
    """Base class for all agents in Agent Development Kit."""
    _ALIASES: dict[str, str] = {'describe': 'description'}
    _CALLBACK_ALIASES: dict[str, str] = {'after_agent': 'after_agent_callback', 'before_agent': 'before_agent_callback'}
    _ADDITIVE_FIELDS: set[str] = {'after_agent_callback', 'before_agent_callback'}
    _ADK_TARGET_CLASS = _ADK_BaseAgent
    def __init__(self, name: str) -> None: ...
    def describe(self, value: str) -> Self: ...
    def after_agent(self, *fns: Callable[..., Any]) -> Self: ...
    def after_agent_if(self, condition: bool, fn: Callable[..., Any]) -> Self: ...
    def before_agent(self, *fns: Callable[..., Any]) -> Self: ...
    def before_agent_if(self, condition: bool, fn: Callable[..., Any]) -> Self: ...
    def sub_agents(self, value: list[BaseAgent]) -> Self: ...
    def sub_agent(self, value: BaseAgent) -> Self: ...
    def build(self) -> _ADK_BaseAgent: ...


class Agent(BuilderBase):
    """LLM-based Agent."""
    _ALIASES: dict[str, str] = {'describe': 'description', 'global_instruct': 'global_instruction', 'history': 'include_contents', 'include_history': 'include_contents', 'instruct': 'instruction', 'outputs': 'output_key', 'static': 'static_instruction', 'static_instruct': 'static_instruction'}
    _CALLBACK_ALIASES: dict[str, str] = {'after_agent': 'after_agent_callback', 'after_model': 'after_model_callback', 'after_tool': 'after_tool_callback', 'before_agent': 'before_agent_callback', 'before_model': 'before_model_callback', 'before_tool': 'before_tool_callback', 'on_model_error': 'on_model_error_callback', 'on_tool_error': 'on_tool_error_callback'}
    _ADDITIVE_FIELDS: set[str] = {'after_tool_callback', 'after_agent_callback', 'after_model_callback', 'on_model_error_callback', 'before_model_callback', 'before_tool_callback', 'before_agent_callback', 'on_tool_error_callback'}
    _ADK_TARGET_CLASS = LlmAgent
    def __init__(self, name: str, model: str | None = None) -> None: ...
    def describe(self, value: str) -> Self: ...
    def global_instruct(self, value: str | Callable[ReadonlyContext, str | Awaitable[str]]) -> Self: ...
    def history(self, value: Literal['default', 'none']) -> Self: ...
    def include_history(self, value: Literal['default', 'none']) -> Self: ...
    def instruct(self, value: str | Callable[ReadonlyContext, str | Awaitable[str]]) -> Self: ...
    def outputs(self, value: str | None) -> Self: ...
    def static(self, value: Content | str | File | Part | list[str | File | Part] | None) -> Self: ...
    def static_instruct(self, value: Content | str | File | Part | list[str | File | Part] | None) -> Self: ...
    def after_agent(self, *fns: Callable[..., Any]) -> Self: ...
    def after_agent_if(self, condition: bool, fn: Callable[..., Any]) -> Self: ...
    def after_model(self, *fns: Callable[..., Any]) -> Self: ...
    def after_model_if(self, condition: bool, fn: Callable[..., Any]) -> Self: ...
    def after_tool(self, *fns: Callable[..., Any]) -> Self: ...
    def after_tool_if(self, condition: bool, fn: Callable[..., Any]) -> Self: ...
    def before_agent(self, *fns: Callable[..., Any]) -> Self: ...
    def before_agent_if(self, condition: bool, fn: Callable[..., Any]) -> Self: ...
    def before_model(self, *fns: Callable[..., Any]) -> Self: ...
    def before_model_if(self, condition: bool, fn: Callable[..., Any]) -> Self: ...
    def before_tool(self, *fns: Callable[..., Any]) -> Self: ...
    def before_tool_if(self, condition: bool, fn: Callable[..., Any]) -> Self: ...
    def on_model_error(self, *fns: Callable[..., Any]) -> Self: ...
    def on_model_error_if(self, condition: bool, fn: Callable[..., Any]) -> Self: ...
    def on_tool_error(self, *fns: Callable[..., Any]) -> Self: ...
    def on_tool_error_if(self, condition: bool, fn: Callable[..., Any]) -> Self: ...
    def sub_agents(self, value: list[BaseAgent]) -> Self: ...
    def model(self, value: str | BaseLlm) -> Self: ...
    def tools(self, value: list[Callable | BaseTool | BaseToolset]) -> Self: ...
    def generate_content_config(self, value: GenerateContentConfig | None) -> Self: ...
    def disallow_transfer_to_parent(self, value: bool) -> Self: ...
    def disallow_transfer_to_peers(self, value: bool) -> Self: ...
    def input_schema(self, value: type[BaseModel] | None) -> Self: ...
    def output_schema(self, value: type[BaseModel] | None) -> Self: ...
    def planner(self, value: BasePlanner | None) -> Self: ...
    def code_executor(self, value: BaseCodeExecutor | None) -> Self: ...
    def sub_agent(self, value: BaseAgent) -> Self: ...
    def tool(self, fn_or_tool, *, require_confirmation: bool = False) -> Self: ...
    def guardrail(self, fn: Callable) -> Self: ...
    def ask(self, prompt: str) -> str: ...
    async def ask_async(self, prompt: str) -> str: ...
    async def stream(self, prompt: str) -> AsyncIterator[str]: ...
    def test(self, prompt: str, *, contains: str | None = None, matches: str | None = None, equals: str | None = None) -> Self: ...
    def session(self) -> Any: ...
    def map(self, prompts: list[str], *, concurrency: int = 5) -> list[str]: ...
    async def map_async(self, prompts: list[str], *, concurrency: int = 5) -> list[str]: ...
    async def events(self, prompt: str) -> AsyncIterator: ...
    def context(self, spec: Any) -> Self: ...
    def show(self) -> Self: ...
    def hide(self) -> Self: ...
    def memory(self, mode: str = 'preload') -> Self: ...
    def memory_auto_save(self) -> Self: ...
    def delegate(self, agent) -> Self: ...
    def isolate(self) -> Self: ...
    def to_ir(self) -> Any: ...
    def build(self) -> LlmAgent: ...
