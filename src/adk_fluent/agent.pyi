# AUTO-GENERATED by adk-fluent generator â€” do not edit manually
# Generated from google-adk 1.25.0
# Timestamp: 2026-02-18T23:45:36.307629+00:00

from collections.abc import AsyncGenerator, Callable
from typing import Any, Self

from google.adk.agents.base_agent import BaseAgent as _ADK_BaseAgent
from google.adk.agents.llm_agent import LlmAgent

from adk_fluent._base import BuilderBase

class BaseAgent(BuilderBase):
    """Base class for all agents in Agent Development Kit."""
    def __init__(self, name: str) -> None: ...
    def describe(self, value: str) -> Self:
        """Set the ``description`` field."""
        ...
    def after_agent(self, fn: Callable) -> Self:
        """Append callback to ``after_agent_callback``. Multiple calls accumulate."""
        ...
    def before_agent(self, fn: Callable) -> Self:
        """Append callback to ``before_agent_callback``. Multiple calls accumulate."""
        ...
    def after_agent_if(self, condition: bool, fn: Callable) -> Self:
        """Append callback to ``after_agent_callback`` only if *condition* is True."""
        ...
    def before_agent_if(self, condition: bool, fn: Callable) -> Self:
        """Append callback to ``before_agent_callback`` only if *condition* is True."""
        ...
    def sub_agents(self, value: list[BaseAgent]) -> Self:
        """"""
        ...
    def build(self) -> BaseAgent:
        """Resolve into a native ADK BaseAgent."""
        ...

class Agent(BuilderBase):
    """LLM-based Agent."""
    def __init__(self, name: str, model: str | None = None) -> None: ...
    def describe(self, value: str) -> Self:
        """Set the ``description`` field."""
        ...
    def global_instruct(self, value: Union[str, Callable[ReadonlyContext, Union[str, Awaitable[str]]]]) -> Self:
        """Set the ``global_instruction`` field."""
        ...
    def history(self, value: Literal[default, none]) -> Self:
        """Set the ``include_contents`` field."""
        ...
    def include_history(self, value: Literal[default, none]) -> Self:
        """Set the ``include_contents`` field."""
        ...
    def instruct(self, value: Union[str, Callable[ReadonlyContext, Union[str, Awaitable[str]]]]) -> Self:
        """Set the ``instruction`` field."""
        ...
    def outputs(self, value: Union[str, NoneType]) -> Self:
        """Set the ``output_key`` field."""
        ...
    def static(self, value: Union[Content, str, Image, File, Part, list[Union[str, Image, File, Part]], NoneType]) -> Self:
        """Set the ``static_instruction`` field."""
        ...
    def after_agent(self, fn: Callable) -> Self:
        """Append callback to ``after_agent_callback``. Multiple calls accumulate."""
        ...
    def after_model(self, fn: Callable) -> Self:
        """Append callback to ``after_model_callback``. Multiple calls accumulate."""
        ...
    def after_tool(self, fn: Callable) -> Self:
        """Append callback to ``after_tool_callback``. Multiple calls accumulate."""
        ...
    def before_agent(self, fn: Callable) -> Self:
        """Append callback to ``before_agent_callback``. Multiple calls accumulate."""
        ...
    def before_model(self, fn: Callable) -> Self:
        """Append callback to ``before_model_callback``. Multiple calls accumulate."""
        ...
    def before_tool(self, fn: Callable) -> Self:
        """Append callback to ``before_tool_callback``. Multiple calls accumulate."""
        ...
    def on_model_error(self, fn: Callable) -> Self:
        """Append callback to ``on_model_error_callback``. Multiple calls accumulate."""
        ...
    def on_tool_error(self, fn: Callable) -> Self:
        """Append callback to ``on_tool_error_callback``. Multiple calls accumulate."""
        ...
    def after_agent_if(self, condition: bool, fn: Callable) -> Self:
        """Append callback to ``after_agent_callback`` only if *condition* is True."""
        ...
    def after_model_if(self, condition: bool, fn: Callable) -> Self:
        """Append callback to ``after_model_callback`` only if *condition* is True."""
        ...
    def after_tool_if(self, condition: bool, fn: Callable) -> Self:
        """Append callback to ``after_tool_callback`` only if *condition* is True."""
        ...
    def before_agent_if(self, condition: bool, fn: Callable) -> Self:
        """Append callback to ``before_agent_callback`` only if *condition* is True."""
        ...
    def before_model_if(self, condition: bool, fn: Callable) -> Self:
        """Append callback to ``before_model_callback`` only if *condition* is True."""
        ...
    def before_tool_if(self, condition: bool, fn: Callable) -> Self:
        """Append callback to ``before_tool_callback`` only if *condition* is True."""
        ...
    def on_model_error_if(self, condition: bool, fn: Callable) -> Self:
        """Append callback to ``on_model_error_callback`` only if *condition* is True."""
        ...
    def on_tool_error_if(self, condition: bool, fn: Callable) -> Self:
        """Append callback to ``on_tool_error_callback`` only if *condition* is True."""
        ...
    def sub_agents(self, value: list[BaseAgent]) -> Self:
        """"""
        ...
    def model(self, value: Union[str, BaseLlm]) -> Self:
        """"""
        ...
    def tools(self, value: list[Union[Callable, BaseTool, BaseToolset]]) -> Self:
        """"""
        ...
    def generate_content_config(self, value: Union[GenerateContentConfig, NoneType]) -> Self:
        """"""
        ...
    def disallow_transfer_to_parent(self, value: bool) -> Self:
        """"""
        ...
    def disallow_transfer_to_peers(self, value: bool) -> Self:
        """"""
        ...
    def input_schema(self, value: Union[type[BaseModel], NoneType]) -> Self:
        """"""
        ...
    def output_schema(self, value: Union[type[BaseModel], NoneType]) -> Self:
        """"""
        ...
    def planner(self, value: Union[BasePlanner, NoneType]) -> Self:
        """"""
        ...
    def code_executor(self, value: Union[BaseCodeExecutor, NoneType]) -> Self:
        """"""
        ...
    def apply(self, stack: MiddlewareStack) -> Self:
        """Apply a reusable middleware stack (bulk callback registration)."""
        ...
    def sub_agent(self, agent: BaseAgent | AgentBuilder) -> Self:
        """Add a sub-agent (appends). Multiple .sub_agent() calls accumulate."""
        ...
    def member(self, agent: BaseAgent | AgentBuilder) -> Self:
        """Deprecated: use .sub_agent() instead. Add a sub-agent for coordinator pattern."""
        ...
    def delegate(self, agent) -> Self:
        """Add an agent as a delegatable tool (wraps in AgentTool). The coordinator LLM can route to this agent."""
        ...
    def tool(self, fn_or_tool, *, require_confirmation: bool = False) -> Self:
        """Add a single tool (appends). Wraps plain callables in FunctionTool when require_confirmation=True."""
        ...
    def guardrail(self, fn: Callable) -> Self:
        """Attach a guardrail function as both before_model and after_model callback."""
        ...
    def ask(self, prompt: str) -> str:
        """One-shot execution. Build agent, send prompt, return response text."""
        ...
    async def ask_async(self, prompt: str) -> str:
        """Async one-shot execution."""
        ...
    async def stream(self, prompt: str) -> AsyncIterator[str]:
        """Streaming execution. Yields response text chunks."""
        ...
    def test(self, prompt: str, *, contains: str | None = None, matches: str | None = None, equals: str | None = None) -> Self:
        """Run a smoke test. Calls .ask() internally, asserts output matches condition."""
        ...
    def session(self):
        """Create an interactive session context manager. Use with 'async with'."""
        ...
    def map(self, prompts: list[str], *, concurrency: int = 5) -> list[str]:
        """Run agent against multiple prompts with bounded concurrency."""
        ...
    async def map_async(self, prompts: list[str], *, concurrency: int = 5) -> list[str]:
        """Async batch execution against multiple prompts."""
        ...
    async def events(self, prompt: str) -> AsyncIterator:
        """Stream raw ADK Event objects. Yields every event including state deltas and function calls."""
        ...
    def context(self, spec: Any) -> Self:
        """Declare what conversation context this agent should see. Accepts a C module transform (C.none(), C.user_only(), C.from_state(), etc.)."""
        ...
    def show(self) -> Self:
        """Force this agent's events to be user-facing (override topology inference)."""
        ...
    def hide(self) -> Self:
        """Force this agent's events to be internal (override topology inference)."""
        ...
    def memory(self, mode: str = 'preload') -> Self:
        """Add memory tools to this agent. Modes: 'preload', 'on_demand', 'both'."""
        ...
    def memory_auto_save(self) -> Self:
        """Auto-save session to memory after each agent run."""
        ...
    def to_ir(self):
        """Convert this Agent builder to an AgentNode IR node."""
        ...
    def build(self) -> LlmAgent:
        """Resolve into a native ADK LlmAgent."""
        ...
