"""Auto-generated by adk-fluent generator. Manual edits will be overwritten."""

from __future__ import annotations
from collections import defaultdict
from typing import Any, Callable, Self
from google.adk.artifacts.base_artifact_service import BaseArtifactService
from google.adk.artifacts.file_artifact_service import FileArtifactService
from google.adk.artifacts.gcs_artifact_service import GcsArtifactService
from google.adk.artifacts.in_memory_artifact_service import InMemoryArtifactService
from google.adk.cli.utils.local_storage import PerAgentDatabaseSessionService
from google.adk.memory.base_memory_service import BaseMemoryService
from google.adk.memory.in_memory_memory_service import InMemoryMemoryService
from google.adk.memory.vertex_ai_memory_bank_service import VertexAiMemoryBankService
from google.adk.memory.vertex_ai_rag_memory_service import VertexAiRagMemoryService
from google.adk.sessions.base_session_service import BaseSessionService
from google.adk.sessions.database_session_service import DatabaseSessionService
from google.adk.sessions.in_memory_session_service import InMemorySessionService
from google.adk.sessions.sqlite_session_service import SqliteSessionService
from google.adk.sessions.vertex_ai_session_service import VertexAiSessionService
from google.adk.tools._forwarding_artifact_service import ForwardingArtifactService

# ======================================================================
# Builder: BaseArtifactService
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = set()

class BaseArtifactService:
    """Abstract base class for artifact services."""


    def __init__(self, args: str, kwargs: str) -> None:
        self._config: dict[str, Any] = {"args": args, "kwargs": kwargs}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to BaseArtifactService init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on BaseArtifactService. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> BaseArtifactService:
        """Abstract base class for artifact services. Resolve into a native ADK BaseArtifactService."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return BaseArtifactService(**config)


# ======================================================================
# Builder: FileArtifactService
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'root_dir'}

class FileArtifactService:
    """Stores filesystem-backed artifacts beneath a configurable root directory."""


    def __init__(self, root_dir: str) -> None:
        self._config: dict[str, Any] = {"root_dir": root_dir}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to FileArtifactService init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on FileArtifactService. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> FileArtifactService:
        """Stores filesystem-backed artifacts beneath a configurable root directory. Resolve into a native ADK FileArtifactService."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return FileArtifactService(**config)


# ======================================================================
# Builder: GcsArtifactService
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'bucket_name'}

class GcsArtifactService:
    """An artifact service implementation using Google Cloud Storage (GCS)."""


    def __init__(self, bucket_name: str, kwargs: str) -> None:
        self._config: dict[str, Any] = {"bucket_name": bucket_name, "kwargs": kwargs}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to GcsArtifactService init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on GcsArtifactService. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> GcsArtifactService:
        """An artifact service implementation using Google Cloud Storage (GCS). Resolve into a native ADK GcsArtifactService."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return GcsArtifactService(**config)


# ======================================================================
# Builder: InMemoryArtifactService
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()

class InMemoryArtifactService:
    """An in-memory implementation of the artifact service."""


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to InMemoryArtifactService.model_fields for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against actual Pydantic schema
        if field_name not in InMemoryArtifactService.model_fields:
            available = sorted(
                set(InMemoryArtifactService.model_fields.keys())
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized field on InMemoryArtifactService. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> InMemoryArtifactService:
        """An in-memory implementation of the artifact service. Resolve into a native ADK InMemoryArtifactService."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return InMemoryArtifactService(**config)


# ======================================================================
# Builder: PerAgentDatabaseSessionService
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'app_name_to_dir', 'agents_root'}

class PerAgentDatabaseSessionService:
    """Routes session storage to per-agent `.adk/session.db` files."""


    def __init__(self, agents_root: str) -> None:
        self._config: dict[str, Any] = {"agents_root": agents_root}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to PerAgentDatabaseSessionService init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on PerAgentDatabaseSessionService. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> PerAgentDatabaseSessionService:
        """Routes session storage to per-agent `.adk/session.db` files. Resolve into a native ADK PerAgentDatabaseSessionService."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return PerAgentDatabaseSessionService(**config)


# ======================================================================
# Builder: BaseMemoryService
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = set()

class BaseMemoryService:
    """Base class for memory services."""


    def __init__(self, args: str, kwargs: str) -> None:
        self._config: dict[str, Any] = {"args": args, "kwargs": kwargs}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to BaseMemoryService init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on BaseMemoryService. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> BaseMemoryService:
        """Base class for memory services. Resolve into a native ADK BaseMemoryService."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return BaseMemoryService(**config)


# ======================================================================
# Builder: InMemoryMemoryService
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = set()

class InMemoryMemoryService:
    """An in-memory memory service for prototyping purpose only."""


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to InMemoryMemoryService init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on InMemoryMemoryService. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> InMemoryMemoryService:
        """An in-memory memory service for prototyping purpose only. Resolve into a native ADK InMemoryMemoryService."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return InMemoryMemoryService(**config)


# ======================================================================
# Builder: VertexAiMemoryBankService
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'project', 'location', 'agent_engine_id', 'express_mode_api_key'}

class VertexAiMemoryBankService:
    """Implementation of the BaseMemoryService using Vertex AI Memory Bank."""


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to VertexAiMemoryBankService init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on VertexAiMemoryBankService. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> VertexAiMemoryBankService:
        """Implementation of the BaseMemoryService using Vertex AI Memory Bank. Resolve into a native ADK VertexAiMemoryBankService."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return VertexAiMemoryBankService(**config)


# ======================================================================
# Builder: VertexAiRagMemoryService
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'rag_corpus', 'similarity_top_k', 'vector_distance_threshold'}

class VertexAiRagMemoryService:
    """A memory service that uses Vertex AI RAG for storage and retrieval."""


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to VertexAiRagMemoryService init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on VertexAiRagMemoryService. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> VertexAiRagMemoryService:
        """A memory service that uses Vertex AI RAG for storage and retrieval. Resolve into a native ADK VertexAiRagMemoryService."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return VertexAiRagMemoryService(**config)


# ======================================================================
# Builder: BaseSessionService
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = set()

class BaseSessionService:
    """Base class for session services."""


    def __init__(self, args: str, kwargs: str) -> None:
        self._config: dict[str, Any] = {"args": args, "kwargs": kwargs}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to BaseSessionService init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on BaseSessionService. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> BaseSessionService:
        """Base class for session services. Resolve into a native ADK BaseSessionService."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return BaseSessionService(**config)


# ======================================================================
# Builder: DatabaseSessionService
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'db_url'}

class DatabaseSessionService:
    """A session service that uses a database for storage."""


    def __init__(self, db_url: str, kwargs: str) -> None:
        self._config: dict[str, Any] = {"db_url": db_url, "kwargs": kwargs}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to DatabaseSessionService init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on DatabaseSessionService. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> DatabaseSessionService:
        """A session service that uses a database for storage. Resolve into a native ADK DatabaseSessionService."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return DatabaseSessionService(**config)


# ======================================================================
# Builder: InMemorySessionService
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = set()

class InMemorySessionService:
    """An in-memory implementation of the session service."""


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to InMemorySessionService init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on InMemorySessionService. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> InMemorySessionService:
        """An in-memory implementation of the session service. Resolve into a native ADK InMemorySessionService."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return InMemorySessionService(**config)


# ======================================================================
# Builder: SqliteSessionService
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'db_path'}

class SqliteSessionService:
    """A session service that uses an SQLite database for storage via aiosqlite."""


    def __init__(self, db_path: str) -> None:
        self._config: dict[str, Any] = {"db_path": db_path}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to SqliteSessionService init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on SqliteSessionService. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> SqliteSessionService:
        """A session service that uses an SQLite database for storage via aiosqlite. Resolve into a native ADK SqliteSessionService."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return SqliteSessionService(**config)


# ======================================================================
# Builder: VertexAiSessionService
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'project', 'location', 'agent_engine_id', 'express_mode_api_key'}

class VertexAiSessionService:
    """Connects to the Vertex AI Agent Engine Session Service using Agent Engine SDK."""


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to VertexAiSessionService init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on VertexAiSessionService. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> VertexAiSessionService:
        """Connects to the Vertex AI Agent Engine Session Service using Agent Engine SDK. Resolve into a native ADK VertexAiSessionService."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return VertexAiSessionService(**config)


# ======================================================================
# Builder: ForwardingArtifactService
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'tool_context'}

class ForwardingArtifactService:
    """Artifact service that forwards to the parent tool context."""


    def __init__(self, tool_context: str) -> None:
        self._config: dict[str, Any] = {"tool_context": tool_context}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to ForwardingArtifactService init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on ForwardingArtifactService. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> ForwardingArtifactService:
        """Artifact service that forwards to the parent tool context. Resolve into a native ADK ForwardingArtifactService."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return ForwardingArtifactService(**config)
