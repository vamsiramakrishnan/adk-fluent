"""Auto-generated by adk-fluent generator. Manual edits will be overwritten."""

from __future__ import annotations
from collections import defaultdict
from typing import Any, Callable, Self
from adk_fluent._base import BuilderBase
from google.adk.planners.base_planner import BasePlanner as _ADK_BasePlanner
from google.adk.planners.built_in_planner import BuiltInPlanner as _ADK_BuiltInPlanner
from google.adk.planners.plan_re_act_planner import PlanReActPlanner as _ADK_PlanReActPlanner

# ======================================================================
# Builder: BasePlanner
# ======================================================================

class BasePlanner(BuilderBase):
    """Abstract base class for all planners."""

    # --- Class-level alias / field maps ---
    _ALIASES: dict[str, str] = {}
    _CALLBACK_ALIASES: dict[str, str] = {}
    _ADDITIVE_FIELDS: set[str] = set()
    _KNOWN_PARAMS: set[str] = set()


    def __init__(self, args: str, kwargs: str) -> None:
        self._config: dict[str, Any] = {"args": args, "kwargs": kwargs}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to _ADK_BasePlanner init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map (class-level constants)
        _ALIASES = self.__class__._ALIASES
        _CALLBACK_ALIASES = self.__class__._CALLBACK_ALIASES
        _ADDITIVE_FIELDS = self.__class__._ADDITIVE_FIELDS
        _KNOWN_PARAMS = self.__class__._KNOWN_PARAMS

        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on _ADK_BasePlanner. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> _ADK_BasePlanner:
        """Abstract base class for all planners. Resolve into a native ADK _ADK_BasePlanner."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return _ADK_BasePlanner(**config)


# ======================================================================
# Builder: BuiltInPlanner
# ======================================================================

class BuiltInPlanner(BuilderBase):
    """The built-in planner that uses model's built-in thinking features."""

    # --- Class-level alias / field maps ---
    _ALIASES: dict[str, str] = {}
    _CALLBACK_ALIASES: dict[str, str] = {}
    _ADDITIVE_FIELDS: set[str] = set()
    _KNOWN_PARAMS: set[str] = {'thinking_config'}


    def __init__(self, thinking_config: str) -> None:
        self._config: dict[str, Any] = {"thinking_config": thinking_config}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to _ADK_BuiltInPlanner init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map (class-level constants)
        _ALIASES = self.__class__._ALIASES
        _CALLBACK_ALIASES = self.__class__._CALLBACK_ALIASES
        _ADDITIVE_FIELDS = self.__class__._ADDITIVE_FIELDS
        _KNOWN_PARAMS = self.__class__._KNOWN_PARAMS

        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on _ADK_BuiltInPlanner. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> _ADK_BuiltInPlanner:
        """The built-in planner that uses model's built-in thinking features. Resolve into a native ADK _ADK_BuiltInPlanner."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return _ADK_BuiltInPlanner(**config)


# ======================================================================
# Builder: PlanReActPlanner
# ======================================================================

class PlanReActPlanner(BuilderBase):
    """Plan-Re-Act planner that constrains the LLM response to generate a plan before any action/observation."""

    # --- Class-level alias / field maps ---
    _ALIASES: dict[str, str] = {}
    _CALLBACK_ALIASES: dict[str, str] = {}
    _ADDITIVE_FIELDS: set[str] = set()
    _KNOWN_PARAMS: set[str] = set()


    def __init__(self, args: str, kwargs: str) -> None:
        self._config: dict[str, Any] = {"args": args, "kwargs": kwargs}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to _ADK_PlanReActPlanner init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map (class-level constants)
        _ALIASES = self.__class__._ALIASES
        _CALLBACK_ALIASES = self.__class__._CALLBACK_ALIASES
        _ADDITIVE_FIELDS = self.__class__._ADDITIVE_FIELDS
        _KNOWN_PARAMS = self.__class__._KNOWN_PARAMS

        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on _ADK_PlanReActPlanner. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> _ADK_PlanReActPlanner:
        """Plan-Re-Act planner that constrains the LLM response to generate a plan before any action/observation. Resolve into a native ADK _ADK_PlanReActPlanner."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return _ADK_PlanReActPlanner(**config)
