"""Auto-generated by adk-fluent generator. Manual edits will be overwritten."""

from __future__ import annotations
from collections import defaultdict
from typing import Any, Callable, Self
from google.adk.agents.active_streaming_tool import ActiveStreamingTool
from google.adk.tools.agent_tool import AgentTool
from google.adk.tools.apihub_tool.apihub_toolset import APIHubToolset
from google.adk.tools.application_integration_tool.application_integration_toolset import ApplicationIntegrationToolset
from google.adk.tools.application_integration_tool.integration_connector_tool import IntegrationConnectorTool
from google.adk.tools.base_authenticated_tool import BaseAuthenticatedTool
from google.adk.tools.base_tool import BaseTool
from google.adk.tools.base_toolset import BaseToolset
from google.adk.tools.bigquery.bigquery_toolset import BigQueryToolset
from google.adk.tools.bigtable.bigtable_toolset import BigtableToolset
from google.adk.tools.computer_use.computer_use_tool import ComputerUseTool
from google.adk.tools.computer_use.computer_use_toolset import ComputerUseToolset
from google.adk.tools.data_agent.data_agent_toolset import DataAgentToolset
from google.adk.tools.discovery_engine_search_tool import DiscoveryEngineSearchTool
from google.adk.tools.enterprise_search_tool import EnterpriseWebSearchTool
from google.adk.tools.example_tool import ExampleTool
from google.adk.tools.function_tool import FunctionTool
from google.adk.tools.google_api_tool.google_api_tool import GoogleApiTool
from google.adk.tools.google_api_tool.google_api_toolset import GoogleApiToolset
from google.adk.tools.google_api_tool.google_api_toolsets import CalendarToolset
from google.adk.tools.google_api_tool.google_api_toolsets import DocsToolset
from google.adk.tools.google_api_tool.google_api_toolsets import GmailToolset
from google.adk.tools.google_api_tool.google_api_toolsets import SheetsToolset
from google.adk.tools.google_api_tool.google_api_toolsets import SlidesToolset
from google.adk.tools.google_api_tool.google_api_toolsets import YoutubeToolset
from google.adk.tools.google_maps_grounding_tool import GoogleMapsGroundingTool
from google.adk.tools.google_search_agent_tool import GoogleSearchAgentTool
from google.adk.tools.google_search_tool import GoogleSearchTool
from google.adk.tools.google_tool import GoogleTool
from google.adk.tools.load_artifacts_tool import LoadArtifactsTool
from google.adk.tools.load_mcp_resource_tool import LoadMcpResourceTool
from google.adk.tools.load_memory_tool import LoadMemoryTool
from google.adk.tools.long_running_tool import LongRunningFunctionTool
from google.adk.tools.mcp_tool.mcp_tool import MCPTool
from google.adk.tools.mcp_tool.mcp_tool import McpTool
from google.adk.tools.mcp_tool.mcp_toolset import MCPToolset
from google.adk.tools.mcp_tool.mcp_toolset import McpToolset
from google.adk.tools.openapi_tool.openapi_spec_parser.openapi_toolset import OpenAPIToolset
from google.adk.tools.openapi_tool.openapi_spec_parser.rest_api_tool import RestApiTool
from google.adk.tools.preload_memory_tool import PreloadMemoryTool
from google.adk.tools.pubsub.pubsub_toolset import PubSubToolset
from google.adk.tools.retrieval.base_retrieval_tool import BaseRetrievalTool
from google.adk.tools.set_model_response_tool import SetModelResponseTool
from google.adk.tools.skill_toolset import LoadSkillResourceTool
from google.adk.tools.skill_toolset import LoadSkillTool
from google.adk.tools.skill_toolset import SkillToolset
from google.adk.tools.spanner.spanner_toolset import SpannerToolset
from google.adk.tools.toolbox_toolset import ToolboxToolset
from google.adk.tools.transfer_to_agent_tool import TransferToAgentTool
from google.adk.tools.url_context_tool import UrlContextTool
from google.adk.tools.vertex_ai_search_tool import VertexAiSearchTool

# ======================================================================
# Builder: ActiveStreamingTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()

class ActiveStreamingTool:
    """Manages streaming tool related resources during invocation."""


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to ActiveStreamingTool.model_fields for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against actual Pydantic schema
        if field_name not in ActiveStreamingTool.model_fields:
            available = sorted(
                set(ActiveStreamingTool.model_fields.keys())
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized field on ActiveStreamingTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> ActiveStreamingTool:
        """Manages streaming tool related resources during invocation. Resolve into a native ADK ActiveStreamingTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return ActiveStreamingTool(**config)


# ======================================================================
# Builder: AgentTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'skip_summarization', 'agent', 'include_plugins'}

class AgentTool:
    """A tool that wraps an agent."""


    def __init__(self, agent: str) -> None:
        self._config: dict[str, Any] = {"agent": agent}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to AgentTool init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on AgentTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> AgentTool:
        """A tool that wraps an agent. Resolve into a native ADK AgentTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return AgentTool(**config)


# ======================================================================
# Builder: APIHubToolset
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'description', 'access_token', 'apihub_client', 'tool_filter', 'name', 'service_account_json', 'auth_scheme', 'apihub_resource_name', 'auth_credential', 'lazy_load_spec'}

class APIHubToolset:
    """APIHubTool generates tools from a given API Hub resource."""


    def __init__(self, apihub_resource_name: str) -> None:
        self._config: dict[str, Any] = {"apihub_resource_name": apihub_resource_name}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to APIHubToolset init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on APIHubToolset. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> APIHubToolset:
        """APIHubTool generates tools from a given API Hub resource. Resolve into a native ADK APIHubToolset."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return APIHubToolset(**config)


# ======================================================================
# Builder: ApplicationIntegrationToolset
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'actions', 'entity_operations', 'tool_filter', 'location', 'service_account_json', 'connection_template_override', 'connection', 'triggers', 'tool_name_prefix', 'auth_scheme', 'integration', 'auth_credential', 'project', 'tool_instructions'}

class ApplicationIntegrationToolset:
    """ApplicationIntegrationToolset generates tools from a given Application."""


    def __init__(self, project: str, location: str) -> None:
        self._config: dict[str, Any] = {"project": project, "location": location}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to ApplicationIntegrationToolset init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on ApplicationIntegrationToolset. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> ApplicationIntegrationToolset:
        """ApplicationIntegrationToolset generates tools from a given Application. Resolve into a native ADK ApplicationIntegrationToolset."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return ApplicationIntegrationToolset(**config)


# ======================================================================
# Builder: IntegrationConnectorTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'description', 'entity', 'action', 'connection_name', 'name', 'rest_api_tool', 'operation', 'auth_scheme', 'auth_credential', 'connection_service_name', 'connection_host'}

class IntegrationConnectorTool:
    """A tool that wraps a RestApiTool to interact with a specific Application Integration endpoint."""


    def __init__(self, name: str, description: str, connection_name: str) -> None:
        self._config: dict[str, Any] = {"name": name, "description": description, "connection_name": connection_name}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to IntegrationConnectorTool init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on IntegrationConnectorTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> IntegrationConnectorTool:
        """A tool that wraps a RestApiTool to interact with a specific Application Integration endpoint. Resolve into a native ADK IntegrationConnectorTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return IntegrationConnectorTool(**config)


# ======================================================================
# Builder: BaseAuthenticatedTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'description', 'name', 'response_for_auth_required', 'auth_config'}

class BaseAuthenticatedTool:
    """A base tool class that handles authentication before the actual tool logic."""


    def __init__(self, name: str, description: str) -> None:
        self._config: dict[str, Any] = {"name": name, "description": description}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to BaseAuthenticatedTool init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on BaseAuthenticatedTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> BaseAuthenticatedTool:
        """A base tool class that handles authentication before the actual tool logic. Resolve into a native ADK BaseAuthenticatedTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return BaseAuthenticatedTool(**config)


# ======================================================================
# Builder: BaseTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'description', 'name', 'is_long_running', 'custom_metadata'}

class BaseTool:
    """The base class for all tools."""


    def __init__(self, name: str, description: str) -> None:
        self._config: dict[str, Any] = {"name": name, "description": description}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to BaseTool init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on BaseTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> BaseTool:
        """The base class for all tools. Resolve into a native ADK BaseTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return BaseTool(**config)


# ======================================================================
# Builder: BaseToolset
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'tool_name_prefix', 'tool_filter'}

class BaseToolset:
    """Base class for toolset."""


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to BaseToolset init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on BaseToolset. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> BaseToolset:
        """Base class for toolset. Resolve into a native ADK BaseToolset."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return BaseToolset(**config)


# ======================================================================
# Builder: BigQueryToolset
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'bigquery_tool_config', 'tool_filter', 'credentials_config'}

class BigQueryToolset:
    """BigQuery Toolset contains tools for interacting with BigQuery data and metadata."""


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to BigQueryToolset init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on BigQueryToolset. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> BigQueryToolset:
        """BigQuery Toolset contains tools for interacting with BigQuery data and metadata. Resolve into a native ADK BigQueryToolset."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return BigQueryToolset(**config)


# ======================================================================
# Builder: BigtableToolset
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'tool_filter', 'credentials_config', 'bigtable_tool_settings'}

class BigtableToolset:
    """Bigtable Toolset contains tools for interacting with Bigtable data and metadata."""


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to BigtableToolset init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on BigtableToolset. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> BigtableToolset:
        """Bigtable Toolset contains tools for interacting with Bigtable data and metadata. Resolve into a native ADK BigtableToolset."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return BigtableToolset(**config)


# ======================================================================
# Builder: ComputerUseTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'screen_size', 'func', 'virtual_screen_size'}

class ComputerUseTool:
    """A tool that wraps computer control functions for use with LLMs."""


    def __init__(self, func: str, screen_size: str) -> None:
        self._config: dict[str, Any] = {"func": func, "screen_size": screen_size}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to ComputerUseTool init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on ComputerUseTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> ComputerUseTool:
        """A tool that wraps computer control functions for use with LLMs. Resolve into a native ADK ComputerUseTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return ComputerUseTool(**config)


# ======================================================================
# Builder: ComputerUseToolset
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'computer'}

class ComputerUseToolset:
    """Fluent builder for ComputerUseToolset."""


    def __init__(self, computer: str) -> None:
        self._config: dict[str, Any] = {"computer": computer}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to ComputerUseToolset init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on ComputerUseToolset. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> ComputerUseToolset:
        """Fluent builder for ComputerUseToolset. Resolve into a native ADK ComputerUseToolset."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return ComputerUseToolset(**config)


# ======================================================================
# Builder: DataAgentToolset
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'tool_filter', 'credentials_config', 'data_agent_tool_config'}

class DataAgentToolset:
    """Data Agent Toolset contains tools for interacting with data agents."""


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to DataAgentToolset init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on DataAgentToolset. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> DataAgentToolset:
        """Data Agent Toolset contains tools for interacting with data agents. Resolve into a native ADK DataAgentToolset."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return DataAgentToolset(**config)


# ======================================================================
# Builder: DiscoveryEngineSearchTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'max_results', 'filter', 'search_engine_id', 'data_store_id', 'data_store_specs'}

class DiscoveryEngineSearchTool:
    """Tool for searching the discovery engine."""


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to DiscoveryEngineSearchTool init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on DiscoveryEngineSearchTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> DiscoveryEngineSearchTool:
        """Tool for searching the discovery engine. Resolve into a native ADK DiscoveryEngineSearchTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return DiscoveryEngineSearchTool(**config)


# ======================================================================
# Builder: EnterpriseWebSearchTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = set()

class EnterpriseWebSearchTool:
    """A Gemini 2+ built-in tool using web grounding for Enterprise compliance."""


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to EnterpriseWebSearchTool init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on EnterpriseWebSearchTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> EnterpriseWebSearchTool:
        """A Gemini 2+ built-in tool using web grounding for Enterprise compliance. Resolve into a native ADK EnterpriseWebSearchTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return EnterpriseWebSearchTool(**config)


# ======================================================================
# Builder: ExampleTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'examples'}

class ExampleTool:
    """A tool that adds (few-shot) examples to the LLM request."""


    def __init__(self, examples: str) -> None:
        self._config: dict[str, Any] = {"examples": examples}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to ExampleTool init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on ExampleTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> ExampleTool:
        """A tool that adds (few-shot) examples to the LLM request. Resolve into a native ADK ExampleTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return ExampleTool(**config)


# ======================================================================
# Builder: FunctionTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'require_confirmation', 'func'}

class FunctionTool:
    """A tool that wraps a user-defined Python function."""


    def __init__(self, func: str) -> None:
        self._config: dict[str, Any] = {"func": func}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to FunctionTool init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on FunctionTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> FunctionTool:
        """A tool that wraps a user-defined Python function. Resolve into a native ADK FunctionTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return FunctionTool(**config)


# ======================================================================
# Builder: GoogleApiTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'client_secret', 'client_id', 'rest_api_tool', 'service_account', 'additional_headers'}

class GoogleApiTool:
    """Fluent builder for GoogleApiTool."""


    def __init__(self, rest_api_tool: str) -> None:
        self._config: dict[str, Any] = {"rest_api_tool": rest_api_tool}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to GoogleApiTool init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on GoogleApiTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> GoogleApiTool:
        """Fluent builder for GoogleApiTool. Resolve into a native ADK GoogleApiTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return GoogleApiTool(**config)


# ======================================================================
# Builder: GoogleApiToolset
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'api_name', 'client_secret', 'client_id', 'api_version', 'tool_filter', 'service_account', 'additional_headers', 'tool_name_prefix'}

class GoogleApiToolset:
    """Google API Toolset contains tools for interacting with Google APIs."""


    def __init__(self, api_name: str, api_version: str) -> None:
        self._config: dict[str, Any] = {"api_name": api_name, "api_version": api_version}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to GoogleApiToolset init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on GoogleApiToolset. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> GoogleApiToolset:
        """Google API Toolset contains tools for interacting with Google APIs. Resolve into a native ADK GoogleApiToolset."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return GoogleApiToolset(**config)


# ======================================================================
# Builder: CalendarToolset
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'client_secret', 'client_id', 'tool_filter', 'service_account', 'tool_name_prefix'}

class CalendarToolset:
    """Auto-generated Calendar toolset based on Google Calendar API v3 spec exposed by Google API discovery API."""


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to CalendarToolset init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on CalendarToolset. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> CalendarToolset:
        """Auto-generated Calendar toolset based on Google Calendar API v3 spec exposed by Google API discovery API. Resolve into a native ADK CalendarToolset."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return CalendarToolset(**config)


# ======================================================================
# Builder: DocsToolset
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'client_secret', 'client_id', 'tool_filter', 'service_account', 'tool_name_prefix'}

class DocsToolset:
    """Auto-generated Docs toolset based on Google Docs API v1 spec exposed by Google API discovery API."""


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to DocsToolset init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on DocsToolset. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> DocsToolset:
        """Auto-generated Docs toolset based on Google Docs API v1 spec exposed by Google API discovery API. Resolve into a native ADK DocsToolset."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return DocsToolset(**config)


# ======================================================================
# Builder: GmailToolset
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'client_secret', 'client_id', 'tool_filter', 'service_account', 'tool_name_prefix'}

class GmailToolset:
    """Auto-generated Gmail toolset based on Google Gmail API v1 spec exposed by Google API discovery API."""


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to GmailToolset init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on GmailToolset. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> GmailToolset:
        """Auto-generated Gmail toolset based on Google Gmail API v1 spec exposed by Google API discovery API. Resolve into a native ADK GmailToolset."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return GmailToolset(**config)


# ======================================================================
# Builder: SheetsToolset
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'client_secret', 'client_id', 'tool_filter', 'service_account', 'tool_name_prefix'}

class SheetsToolset:
    """Auto-generated Sheets toolset based on Google Sheets API v4 spec exposed by Google API discovery API."""


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to SheetsToolset init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on SheetsToolset. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> SheetsToolset:
        """Auto-generated Sheets toolset based on Google Sheets API v4 spec exposed by Google API discovery API. Resolve into a native ADK SheetsToolset."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return SheetsToolset(**config)


# ======================================================================
# Builder: SlidesToolset
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'client_secret', 'client_id', 'tool_filter', 'service_account', 'tool_name_prefix'}

class SlidesToolset:
    """Auto-generated Slides toolset based on Google Slides API v1 spec exposed by Google API discovery API."""


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to SlidesToolset init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on SlidesToolset. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> SlidesToolset:
        """Auto-generated Slides toolset based on Google Slides API v1 spec exposed by Google API discovery API. Resolve into a native ADK SlidesToolset."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return SlidesToolset(**config)


# ======================================================================
# Builder: YoutubeToolset
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'client_secret', 'client_id', 'tool_filter', 'service_account', 'tool_name_prefix'}

class YoutubeToolset:
    """Auto-generated YouTube toolset based on YouTube API v3 spec exposed by Google API discovery API."""


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to YoutubeToolset init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on YoutubeToolset. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> YoutubeToolset:
        """Auto-generated YouTube toolset based on YouTube API v3 spec exposed by Google API discovery API. Resolve into a native ADK YoutubeToolset."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return YoutubeToolset(**config)


# ======================================================================
# Builder: GoogleMapsGroundingTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = set()

class GoogleMapsGroundingTool:
    """A built-in tool that is automatically invoked by Gemini 2 models to ground query results with Google Maps."""


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to GoogleMapsGroundingTool init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on GoogleMapsGroundingTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> GoogleMapsGroundingTool:
        """A built-in tool that is automatically invoked by Gemini 2 models to ground query results with Google Maps. Resolve into a native ADK GoogleMapsGroundingTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return GoogleMapsGroundingTool(**config)


# ======================================================================
# Builder: GoogleSearchAgentTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'agent'}

class GoogleSearchAgentTool:
    """A tool that wraps a sub-agent that only uses google_search tool."""


    def __init__(self, agent: str) -> None:
        self._config: dict[str, Any] = {"agent": agent}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to GoogleSearchAgentTool init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on GoogleSearchAgentTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> GoogleSearchAgentTool:
        """A tool that wraps a sub-agent that only uses google_search tool. Resolve into a native ADK GoogleSearchAgentTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return GoogleSearchAgentTool(**config)


# ======================================================================
# Builder: GoogleSearchTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'bypass_multi_tools_limit', 'model'}

class GoogleSearchTool:
    """A built-in tool that is automatically invoked by Gemini 2 models to retrieve search results from Google Search."""


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to GoogleSearchTool init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on GoogleSearchTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> GoogleSearchTool:
        """A built-in tool that is automatically invoked by Gemini 2 models to retrieve search results from Google Search. Resolve into a native ADK GoogleSearchTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return GoogleSearchTool(**config)


# ======================================================================
# Builder: GoogleTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'func', 'credentials_config', 'tool_settings'}

class GoogleTool:
    """GoogleTool class for tools that call Google APIs."""


    def __init__(self, func: str) -> None:
        self._config: dict[str, Any] = {"func": func}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to GoogleTool init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on GoogleTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> GoogleTool:
        """GoogleTool class for tools that call Google APIs. Resolve into a native ADK GoogleTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return GoogleTool(**config)


# ======================================================================
# Builder: LoadArtifactsTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = set()

class LoadArtifactsTool:
    """A tool that loads the artifacts and adds them to the session."""


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to LoadArtifactsTool init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on LoadArtifactsTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> LoadArtifactsTool:
        """A tool that loads the artifacts and adds them to the session. Resolve into a native ADK LoadArtifactsTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return LoadArtifactsTool(**config)


# ======================================================================
# Builder: LoadMcpResourceTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'mcp_toolset'}

class LoadMcpResourceTool:
    """A tool that loads the MCP resources and adds them to the session."""


    def __init__(self, mcp_toolset: str) -> None:
        self._config: dict[str, Any] = {"mcp_toolset": mcp_toolset}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to LoadMcpResourceTool init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on LoadMcpResourceTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> LoadMcpResourceTool:
        """A tool that loads the MCP resources and adds them to the session. Resolve into a native ADK LoadMcpResourceTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return LoadMcpResourceTool(**config)


# ======================================================================
# Builder: LoadMemoryTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = set()

class LoadMemoryTool:
    """A tool that loads the memory for the current user."""


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to LoadMemoryTool init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on LoadMemoryTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> LoadMemoryTool:
        """A tool that loads the memory for the current user. Resolve into a native ADK LoadMemoryTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return LoadMemoryTool(**config)


# ======================================================================
# Builder: LongRunningFunctionTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'func'}

class LongRunningFunctionTool:
    """A function tool that returns the result asynchronously."""


    def __init__(self, func: str) -> None:
        self._config: dict[str, Any] = {"func": func}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to LongRunningFunctionTool init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on LongRunningFunctionTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> LongRunningFunctionTool:
        """A function tool that returns the result asynchronously. Resolve into a native ADK LongRunningFunctionTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return LongRunningFunctionTool(**config)


# ======================================================================
# Builder: MCPTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = set()

class MCPTool:
    """Deprecated name, use `McpTool` instead."""


    def __init__(self, args: str, kwargs: str) -> None:
        self._config: dict[str, Any] = {"args": args, "kwargs": kwargs}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to MCPTool init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on MCPTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> MCPTool:
        """Deprecated name, use `McpTool` instead. Resolve into a native ADK MCPTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return MCPTool(**config)


# ======================================================================
# Builder: McpTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'require_confirmation', 'mcp_tool', 'mcp_session_manager', 'auth_scheme', 'progress_callback', 'auth_credential', 'header_provider'}

class McpTool:
    """Turns an MCP Tool into an ADK Tool."""


    def __init__(self, mcp_tool: str, mcp_session_manager: str) -> None:
        self._config: dict[str, Any] = {"mcp_tool": mcp_tool, "mcp_session_manager": mcp_session_manager}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to McpTool init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on McpTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> McpTool:
        """Turns an MCP Tool into an ADK Tool. Resolve into a native ADK McpTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return McpTool(**config)


# ======================================================================
# Builder: MCPToolset
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = set()

class MCPToolset:
    """Deprecated name, use `McpToolset` instead."""


    def __init__(self, args: str, kwargs: str) -> None:
        self._config: dict[str, Any] = {"args": args, "kwargs": kwargs}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to MCPToolset init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on MCPToolset. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> MCPToolset:
        """Deprecated name, use `McpToolset` instead. Resolve into a native ADK MCPToolset."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return MCPToolset(**config)


# ======================================================================
# Builder: McpToolset
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'require_confirmation', 'connection_params', 'tool_filter', 'use_mcp_resources', 'errlog', 'tool_name_prefix', 'auth_scheme', 'progress_callback', 'auth_credential', 'header_provider'}

class McpToolset:
    """Connects to a MCP Server, and retrieves MCP Tools into ADK Tools."""


    def __init__(self, connection_params: str) -> None:
        self._config: dict[str, Any] = {"connection_params": connection_params}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to McpToolset init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on McpToolset. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> McpToolset:
        """Connects to a MCP Server, and retrieves MCP Tools into ADK Tools. Resolve into a native ADK McpToolset."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return McpToolset(**config)


# ======================================================================
# Builder: OpenAPIToolset
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'spec_str', 'spec_dict', 'tool_filter', 'credential_key', 'spec_str_type', 'tool_name_prefix', 'auth_scheme', 'auth_credential', 'ssl_verify', 'header_provider'}

class OpenAPIToolset:
    """Class for parsing OpenAPI spec into a list of RestApiTool."""


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to OpenAPIToolset init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on OpenAPIToolset. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> OpenAPIToolset:
        """Class for parsing OpenAPI spec into a list of RestApiTool. Resolve into a native ADK OpenAPIToolset."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return OpenAPIToolset(**config)


# ======================================================================
# Builder: RestApiTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'description', 'credential_key', 'name', 'operation', 'should_parse_operation', 'auth_scheme', 'auth_credential', 'ssl_verify', 'endpoint', 'header_provider'}

class RestApiTool:
    """A generic tool that interacts with a REST API."""


    def __init__(self, name: str, description: str, endpoint: str) -> None:
        self._config: dict[str, Any] = {"name": name, "description": description, "endpoint": endpoint}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to RestApiTool init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on RestApiTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> RestApiTool:
        """A generic tool that interacts with a REST API. Resolve into a native ADK RestApiTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return RestApiTool(**config)


# ======================================================================
# Builder: PreloadMemoryTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = set()

class PreloadMemoryTool:
    """A tool that preloads the memory for the current user."""


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to PreloadMemoryTool init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on PreloadMemoryTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> PreloadMemoryTool:
        """A tool that preloads the memory for the current user. Resolve into a native ADK PreloadMemoryTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return PreloadMemoryTool(**config)


# ======================================================================
# Builder: PubSubToolset
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'tool_filter', 'pubsub_tool_config', 'credentials_config'}

class PubSubToolset:
    """Pub/Sub Toolset contains tools for interacting with Pub/Sub topics and subscriptions."""


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to PubSubToolset init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on PubSubToolset. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> PubSubToolset:
        """Pub/Sub Toolset contains tools for interacting with Pub/Sub topics and subscriptions. Resolve into a native ADK PubSubToolset."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return PubSubToolset(**config)


# ======================================================================
# Builder: BaseRetrievalTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'description', 'name', 'is_long_running', 'custom_metadata'}

class BaseRetrievalTool:
    """Fluent builder for BaseRetrievalTool."""


    def __init__(self, name: str, description: str) -> None:
        self._config: dict[str, Any] = {"name": name, "description": description}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to BaseRetrievalTool init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on BaseRetrievalTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> BaseRetrievalTool:
        """Fluent builder for BaseRetrievalTool. Resolve into a native ADK BaseRetrievalTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return BaseRetrievalTool(**config)


# ======================================================================
# Builder: SetModelResponseTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'output_schema'}

class SetModelResponseTool:
    """Internal tool used for output schema workaround."""


    def __init__(self, output_schema: str) -> None:
        self._config: dict[str, Any] = {"output_schema": output_schema}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to SetModelResponseTool init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on SetModelResponseTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> SetModelResponseTool:
        """Internal tool used for output schema workaround. Resolve into a native ADK SetModelResponseTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return SetModelResponseTool(**config)


# ======================================================================
# Builder: LoadSkillResourceTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'toolset'}

class LoadSkillResourceTool:
    """Tool to load resources (references or assets) from a skill."""


    def __init__(self, toolset: str) -> None:
        self._config: dict[str, Any] = {"toolset": toolset}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to LoadSkillResourceTool init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on LoadSkillResourceTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> LoadSkillResourceTool:
        """Tool to load resources (references or assets) from a skill. Resolve into a native ADK LoadSkillResourceTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return LoadSkillResourceTool(**config)


# ======================================================================
# Builder: LoadSkillTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'toolset'}

class LoadSkillTool:
    """Tool to load a skill's instructions."""


    def __init__(self, toolset: str) -> None:
        self._config: dict[str, Any] = {"toolset": toolset}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to LoadSkillTool init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on LoadSkillTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> LoadSkillTool:
        """Tool to load a skill's instructions. Resolve into a native ADK LoadSkillTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return LoadSkillTool(**config)


# ======================================================================
# Builder: SkillToolset
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'skills'}

class SkillToolset:
    """A toolset for managing and interacting with agent skills."""


    def __init__(self, skills: str) -> None:
        self._config: dict[str, Any] = {"skills": skills}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to SkillToolset init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on SkillToolset. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> SkillToolset:
        """A toolset for managing and interacting with agent skills. Resolve into a native ADK SkillToolset."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return SkillToolset(**config)


# ======================================================================
# Builder: SpannerToolset
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'tool_filter', 'credentials_config', 'spanner_tool_settings'}

class SpannerToolset:
    """Spanner Toolset contains tools for interacting with Spanner data, database and table information."""


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to SpannerToolset init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on SpannerToolset. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> SpannerToolset:
        """Spanner Toolset contains tools for interacting with Spanner data, database and table information. Resolve into a native ADK SpannerToolset."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return SpannerToolset(**config)


# ======================================================================
# Builder: ToolboxToolset
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'server_url', 'bound_params', 'toolset_name', 'tool_names', 'auth_token_getters', 'additional_headers', 'credentials'}

class ToolboxToolset:
    """A class that provides access to toolbox toolsets."""


    def __init__(self, server_url: str, kwargs: str) -> None:
        self._config: dict[str, Any] = {"server_url": server_url, "kwargs": kwargs}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to ToolboxToolset init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on ToolboxToolset. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> ToolboxToolset:
        """A class that provides access to toolbox toolsets. Resolve into a native ADK ToolboxToolset."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return ToolboxToolset(**config)


# ======================================================================
# Builder: TransferToAgentTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'agent_names'}

class TransferToAgentTool:
    """A specialized FunctionTool for agent transfer with enum constraints."""


    def __init__(self, agent_names: str) -> None:
        self._config: dict[str, Any] = {"agent_names": agent_names}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to TransferToAgentTool init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on TransferToAgentTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> TransferToAgentTool:
        """A specialized FunctionTool for agent transfer with enum constraints. Resolve into a native ADK TransferToAgentTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return TransferToAgentTool(**config)


# ======================================================================
# Builder: UrlContextTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = set()

class UrlContextTool:
    """A built-in tool that is automatically invoked by Gemini 2 models to retrieve content from the URLs and use that content to inform and shape its response."""


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to UrlContextTool init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on UrlContextTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> UrlContextTool:
        """A built-in tool that is automatically invoked by Gemini 2 models to retrieve content from the URLs and use that content to inform and shape its response. Resolve into a native ADK UrlContextTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return UrlContextTool(**config)


# ======================================================================
# Builder: VertexAiSearchTool
# ======================================================================

_ALIASES: dict[str, str] = {}
_CALLBACK_ALIASES: dict[str, str] = {}
_ADDITIVE_FIELDS: set[str] = set()
_KNOWN_PARAMS: set[str] = {'max_results', 'filter', 'search_engine_id', 'bypass_multi_tools_limit', 'data_store_id', 'data_store_specs'}

class VertexAiSearchTool:
    """A built-in tool using Vertex AI Search."""


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Extra methods ---

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to VertexAiSearchTool init params for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against static _KNOWN_PARAMS set (non-Pydantic class)
        if field_name not in _KNOWN_PARAMS:
            available = sorted(
                _KNOWN_PARAMS
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized parameter on VertexAiSearchTool. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> VertexAiSearchTool:
        """A built-in tool using Vertex AI Search. Resolve into a native ADK VertexAiSearchTool."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return VertexAiSearchTool(**config)
