"""Auto-generated by adk-fluent generator. Manual edits will be overwritten."""

from __future__ import annotations
from collections import defaultdict
from typing import Any, Callable, Self
from google.adk.agents.loop_agent import LoopAgent
from google.adk.agents.parallel_agent import ParallelAgent
from google.adk.agents.sequential_agent import SequentialAgent

# ======================================================================
# Builder: Loop
# ======================================================================

_ALIASES: dict[str, str] = {'describe': 'description'}
_CALLBACK_ALIASES: dict[str, str] = {'after_agent': 'after_agent_callback', 'before_agent': 'before_agent_callback'}
_ADDITIVE_FIELDS: set[str] = {'before_agent_callback', 'after_agent_callback'}

class Loop:
    """A shell agent that run its sub-agents in a loop."""


    def __init__(self, name: str) -> None:
        self._config: dict[str, Any] = {"name": name}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    def describe(self, value: str) -> Self:
        """Set the `description` field."""
        self._config["description"] = value
        return self

    # --- Additive callback methods ---

    def after_agent(self, fn: Callable) -> Self:
        """Append a callback to `after_agent_callback`. Multiple calls accumulate."""
        self._callbacks["after_agent_callback"].append(fn)
        return self


    def before_agent(self, fn: Callable) -> Self:
        """Append a callback to `before_agent_callback`. Multiple calls accumulate."""
        self._callbacks["before_agent_callback"].append(fn)
        return self

    # --- Extra methods ---

    def step(self, agent: BaseAgent | AgentBuilder) -> Self:
        """Append an agent as the next step."""
        item = agent.build() if hasattr(agent, "build") else agent
        self._lists["sub_agents"].append(item)
        return self

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to LoopAgent.model_fields for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against actual Pydantic schema
        if field_name not in LoopAgent.model_fields:
            available = sorted(
                set(LoopAgent.model_fields.keys())
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized field on LoopAgent. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> LoopAgent:
        """A shell agent that run its sub-agents in a loop. Resolve into a native ADK LoopAgent."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return LoopAgent(**config)


# ======================================================================
# Builder: FanOut
# ======================================================================

_ALIASES: dict[str, str] = {'describe': 'description'}
_CALLBACK_ALIASES: dict[str, str] = {'after_agent': 'after_agent_callback', 'before_agent': 'before_agent_callback'}
_ADDITIVE_FIELDS: set[str] = {'before_agent_callback', 'after_agent_callback'}

class FanOut:
    """A shell agent that runs its sub-agents in parallel in an isolated manner."""


    def __init__(self, name: str) -> None:
        self._config: dict[str, Any] = {"name": name}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    def describe(self, value: str) -> Self:
        """Set the `description` field."""
        self._config["description"] = value
        return self

    # --- Additive callback methods ---

    def after_agent(self, fn: Callable) -> Self:
        """Append a callback to `after_agent_callback`. Multiple calls accumulate."""
        self._callbacks["after_agent_callback"].append(fn)
        return self


    def before_agent(self, fn: Callable) -> Self:
        """Append a callback to `before_agent_callback`. Multiple calls accumulate."""
        self._callbacks["before_agent_callback"].append(fn)
        return self

    # --- Extra methods ---

    def branch(self, agent: BaseAgent | AgentBuilder) -> Self:
        """Add a parallel branch agent."""
        item = agent.build() if hasattr(agent, "build") else agent
        self._lists["sub_agents"].append(item)
        return self

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to ParallelAgent.model_fields for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against actual Pydantic schema
        if field_name not in ParallelAgent.model_fields:
            available = sorted(
                set(ParallelAgent.model_fields.keys())
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized field on ParallelAgent. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> ParallelAgent:
        """A shell agent that runs its sub-agents in parallel in an isolated manner. Resolve into a native ADK ParallelAgent."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return ParallelAgent(**config)


# ======================================================================
# Builder: Pipeline
# ======================================================================

_ALIASES: dict[str, str] = {'describe': 'description'}
_CALLBACK_ALIASES: dict[str, str] = {'after_agent': 'after_agent_callback', 'before_agent': 'before_agent_callback'}
_ADDITIVE_FIELDS: set[str] = {'before_agent_callback', 'after_agent_callback'}

class Pipeline:
    """A shell agent that runs its sub-agents in sequence."""


    def __init__(self, name: str) -> None:
        self._config: dict[str, Any] = {"name": name}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    def describe(self, value: str) -> Self:
        """Set the `description` field."""
        self._config["description"] = value
        return self

    # --- Additive callback methods ---

    def after_agent(self, fn: Callable) -> Self:
        """Append a callback to `after_agent_callback`. Multiple calls accumulate."""
        self._callbacks["after_agent_callback"].append(fn)
        return self


    def before_agent(self, fn: Callable) -> Self:
        """Append a callback to `before_agent_callback`. Multiple calls accumulate."""
        self._callbacks["before_agent_callback"].append(fn)
        return self

    # --- Extra methods ---

    def step(self, agent: BaseAgent | AgentBuilder) -> Self:
        """Append an agent as the next step."""
        item = agent.build() if hasattr(agent, "build") else agent
        self._lists["sub_agents"].append(item)
        return self

    # --- Dynamic field forwarding ---

    def __getattr__(self, name: str):
        """Forward unknown methods to SequentialAgent.model_fields for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map
        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against actual Pydantic schema
        if field_name not in SequentialAgent.model_fields:
            available = sorted(
                set(SequentialAgent.model_fields.keys())
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized field on SequentialAgent. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> SequentialAgent:
        """A shell agent that runs its sub-agents in sequence. Resolve into a native ADK SequentialAgent."""
        config = {**self._config}
        
        # Merge accumulated callbacks
        for field, fns in self._callbacks.items():
            if fns:
                config[field] = fns if len(fns) > 1 else fns[0]
        
        # Merge accumulated lists
        for field, items in self._lists.items():
            existing = config.get(field, [])
            if isinstance(existing, list):
                config[field] = existing + items
            else:
                config[field] = items
        
        return SequentialAgent(**config)
