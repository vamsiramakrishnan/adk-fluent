"""Auto-generated by adk-fluent generator. Manual edits will be overwritten."""

from __future__ import annotations

from collections import defaultdict
from collections.abc import Callable
from typing import Any, Self

from google.adk.agents.loop_agent import LoopAgent
from google.adk.agents.parallel_agent import ParallelAgent
from google.adk.agents.sequential_agent import SequentialAgent

from adk_fluent._base import BuilderBase

# ======================================================================
# Builder: Loop
# ======================================================================


class Loop(BuilderBase):
    """A shell agent that run its sub-agents in a loop."""

    # --- Class-level alias / field maps ---
    _ALIASES: dict[str, str] = {"describe": "description"}
    _CALLBACK_ALIASES: dict[str, str] = {"after_agent": "after_agent_callback", "before_agent": "before_agent_callback"}
    _ADDITIVE_FIELDS: set[str] = {"before_agent_callback", "after_agent_callback"}
    _ADK_TARGET_CLASS = LoopAgent

    def __init__(self, name: str) -> None:
        self._config: dict[str, Any] = {"name": name}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    def describe(self, value: str) -> Self:
        """Set the `description` field."""
        self._config["description"] = value
        return self

    # --- Additive callback methods ---

    def after_agent(self, *fns: Callable) -> Self:
        """Append callback(s) to `after_agent_callback`. Multiple calls accumulate."""
        for fn in fns:
            self._callbacks["after_agent_callback"].append(fn)
        return self

    def after_agent_if(self, condition: bool, fn: Callable) -> Self:
        """Append callback to `after_agent_callback` only if condition is True."""
        if condition:
            self._callbacks["after_agent_callback"].append(fn)
        return self

    def before_agent(self, *fns: Callable) -> Self:
        """Append callback(s) to `before_agent_callback`. Multiple calls accumulate."""
        for fn in fns:
            self._callbacks["before_agent_callback"].append(fn)
        return self

    def before_agent_if(self, condition: bool, fn: Callable) -> Self:
        """Append callback to `before_agent_callback` only if condition is True."""
        if condition:
            self._callbacks["before_agent_callback"].append(fn)
        return self

    # --- Explicit field methods ---

    def sub_agents(self, value: list[BaseAgent]) -> Self:
        """Set the ``sub_agents`` field."""
        self._config["sub_agents"] = value
        return self

    def max_iterations(self, value: Union[int, NoneType]) -> Self:
        """Set the ``max_iterations`` field."""
        self._config["max_iterations"] = value
        return self

    # --- Extra methods ---

    def step(self, agent: BaseAgent | AgentBuilder) -> Self:
        """Append an agent as the next step (lazy — built at .build() time)."""
        self._lists["sub_agents"].append(agent)
        return self

    def to_ir(self):
        """Convert this Loop builder to a LoopNode IR node."""
        from adk_fluent._helpers import _loop_to_ir

        return _loop_to_ir(self)

    # --- Dynamic field forwarding (safety net) ---

    # --- Terminal methods ---

    def build(self) -> LoopAgent:
        """A shell agent that run its sub-agents in a loop. Resolve into a native ADK LoopAgent."""
        config = self._prepare_build_config()
        return LoopAgent(**config)


# ======================================================================
# Builder: FanOut
# ======================================================================


class FanOut(BuilderBase):
    """A shell agent that runs its sub-agents in parallel in an isolated manner."""

    # --- Class-level alias / field maps ---
    _ALIASES: dict[str, str] = {"describe": "description"}
    _CALLBACK_ALIASES: dict[str, str] = {"after_agent": "after_agent_callback", "before_agent": "before_agent_callback"}
    _ADDITIVE_FIELDS: set[str] = {"before_agent_callback", "after_agent_callback"}
    _ADK_TARGET_CLASS = ParallelAgent

    def __init__(self, name: str) -> None:
        self._config: dict[str, Any] = {"name": name}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    def describe(self, value: str) -> Self:
        """Set the `description` field."""
        self._config["description"] = value
        return self

    # --- Additive callback methods ---

    def after_agent(self, *fns: Callable) -> Self:
        """Append callback(s) to `after_agent_callback`. Multiple calls accumulate."""
        for fn in fns:
            self._callbacks["after_agent_callback"].append(fn)
        return self

    def after_agent_if(self, condition: bool, fn: Callable) -> Self:
        """Append callback to `after_agent_callback` only if condition is True."""
        if condition:
            self._callbacks["after_agent_callback"].append(fn)
        return self

    def before_agent(self, *fns: Callable) -> Self:
        """Append callback(s) to `before_agent_callback`. Multiple calls accumulate."""
        for fn in fns:
            self._callbacks["before_agent_callback"].append(fn)
        return self

    def before_agent_if(self, condition: bool, fn: Callable) -> Self:
        """Append callback to `before_agent_callback` only if condition is True."""
        if condition:
            self._callbacks["before_agent_callback"].append(fn)
        return self

    # --- Explicit field methods ---

    def sub_agents(self, value: list[BaseAgent]) -> Self:
        """Set the ``sub_agents`` field."""
        self._config["sub_agents"] = value
        return self

    # --- Extra methods ---

    def branch(self, agent: BaseAgent | AgentBuilder) -> Self:
        """Add a parallel branch agent (lazy — built at .build() time)."""
        self._lists["sub_agents"].append(agent)
        return self

    def step(self, agent: BaseAgent | AgentBuilder) -> Self:
        """Alias for .branch() — add a parallel branch. Consistent with Pipeline/Loop API."""
        self._lists["sub_agents"].append(agent)
        return self

    def to_ir(self):
        """Convert this FanOut builder to a ParallelNode IR node."""
        from adk_fluent._helpers import _fanout_to_ir

        return _fanout_to_ir(self)

    # --- Dynamic field forwarding (safety net) ---

    # --- Terminal methods ---

    def build(self) -> ParallelAgent:
        """A shell agent that runs its sub-agents in parallel in an isolated manner. Resolve into a native ADK ParallelAgent."""
        config = self._prepare_build_config()
        return ParallelAgent(**config)


# ======================================================================
# Builder: Pipeline
# ======================================================================


class Pipeline(BuilderBase):
    """A shell agent that runs its sub-agents in sequence."""

    # --- Class-level alias / field maps ---
    _ALIASES: dict[str, str] = {"describe": "description"}
    _CALLBACK_ALIASES: dict[str, str] = {"after_agent": "after_agent_callback", "before_agent": "before_agent_callback"}
    _ADDITIVE_FIELDS: set[str] = {"before_agent_callback", "after_agent_callback"}
    _ADK_TARGET_CLASS = SequentialAgent

    def __init__(self, name: str) -> None:
        self._config: dict[str, Any] = {"name": name}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    def describe(self, value: str) -> Self:
        """Set the `description` field."""
        self._config["description"] = value
        return self

    # --- Additive callback methods ---

    def after_agent(self, *fns: Callable) -> Self:
        """Append callback(s) to `after_agent_callback`. Multiple calls accumulate."""
        for fn in fns:
            self._callbacks["after_agent_callback"].append(fn)
        return self

    def after_agent_if(self, condition: bool, fn: Callable) -> Self:
        """Append callback to `after_agent_callback` only if condition is True."""
        if condition:
            self._callbacks["after_agent_callback"].append(fn)
        return self

    def before_agent(self, *fns: Callable) -> Self:
        """Append callback(s) to `before_agent_callback`. Multiple calls accumulate."""
        for fn in fns:
            self._callbacks["before_agent_callback"].append(fn)
        return self

    def before_agent_if(self, condition: bool, fn: Callable) -> Self:
        """Append callback to `before_agent_callback` only if condition is True."""
        if condition:
            self._callbacks["before_agent_callback"].append(fn)
        return self

    # --- Explicit field methods ---

    def sub_agents(self, value: list[BaseAgent]) -> Self:
        """Set the ``sub_agents`` field."""
        self._config["sub_agents"] = value
        return self

    # --- Extra methods ---

    def step(self, agent: BaseAgent | AgentBuilder) -> Self:
        """Append an agent as the next step (lazy — built at .build() time)."""
        self._lists["sub_agents"].append(agent)
        return self

    def to_ir(self):
        """Convert this Pipeline builder to a SequenceNode IR node."""
        from adk_fluent._helpers import _pipeline_to_ir

        return _pipeline_to_ir(self)

    # --- Dynamic field forwarding (safety net) ---

    # --- Terminal methods ---

    def build(self) -> SequentialAgent:
        """A shell agent that runs its sub-agents in sequence. Resolve into a native ADK SequentialAgent."""
        config = self._prepare_build_config()
        return SequentialAgent(**config)
