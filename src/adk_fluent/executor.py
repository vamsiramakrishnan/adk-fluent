"""Auto-generated by adk-fluent generator. Manual edits will be overwritten."""

from __future__ import annotations
from collections import defaultdict
from typing import Any, Callable, Self
from adk_fluent._base import BuilderBase
from google.adk.code_executors.agent_engine_sandbox_code_executor import AgentEngineSandboxCodeExecutor as _ADK_AgentEngineSandboxCodeExecutor
from google.adk.code_executors.base_code_executor import BaseCodeExecutor as _ADK_BaseCodeExecutor
from google.adk.code_executors.built_in_code_executor import BuiltInCodeExecutor as _ADK_BuiltInCodeExecutor
from google.adk.code_executors.unsafe_local_code_executor import UnsafeLocalCodeExecutor as _ADK_UnsafeLocalCodeExecutor
from google.adk.code_executors.vertex_ai_code_executor import VertexAiCodeExecutor as _ADK_VertexAiCodeExecutor

# ======================================================================
# Builder: AgentEngineSandboxCodeExecutor
# ======================================================================

class AgentEngineSandboxCodeExecutor(BuilderBase):
    """A code executor that uses Agent Engine Code Execution Sandbox to execute code."""

    # --- Class-level alias / field maps ---
    _ALIASES: dict[str, str] = {}
    _CALLBACK_ALIASES: dict[str, str] = {}
    _ADDITIVE_FIELDS: set[str] = set()


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Explicit field methods ---

    def optimize_data_file(self, value: bool) -> Self:
        """Set the ``optimize_data_file`` field."""
        self._config["optimize_data_file"] = value
        return self


    def stateful(self, value: bool) -> Self:
        """Set the ``stateful`` field."""
        self._config["stateful"] = value
        return self


    def error_retry_attempts(self, value: int) -> Self:
        """Set the ``error_retry_attempts`` field."""
        self._config["error_retry_attempts"] = value
        return self


    def code_block_delimiters(self, value: list[tuple[str, str]]) -> Self:
        """Set the ``code_block_delimiters`` field."""
        self._config["code_block_delimiters"] = value
        return self


    def execution_result_delimiters(self, value: tuple[str, str]) -> Self:
        """Set the ``execution_result_delimiters`` field."""
        self._config["execution_result_delimiters"] = value
        return self


    def sandbox_resource_name(self, value: str) -> Self:
        """Set the ``sandbox_resource_name`` field."""
        self._config["sandbox_resource_name"] = value
        return self

    # --- Extra methods ---

    # --- Dynamic field forwarding (safety net) ---

    def __getattr__(self, name: str):
        """Forward unknown methods to _ADK_AgentEngineSandboxCodeExecutor.model_fields for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map (class-level constants)
        _ALIASES = self.__class__._ALIASES
        _CALLBACK_ALIASES = self.__class__._CALLBACK_ALIASES
        _ADDITIVE_FIELDS = self.__class__._ADDITIVE_FIELDS

        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against actual Pydantic schema
        if field_name not in _ADK_AgentEngineSandboxCodeExecutor.model_fields:
            available = sorted(
                set(_ADK_AgentEngineSandboxCodeExecutor.model_fields.keys())
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized field on _ADK_AgentEngineSandboxCodeExecutor. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> _ADK_AgentEngineSandboxCodeExecutor:
        """A code executor that uses Agent Engine Code Execution Sandbox to execute code. Resolve into a native ADK _ADK_AgentEngineSandboxCodeExecutor."""
        config = self._prepare_build_config()
        return _ADK_AgentEngineSandboxCodeExecutor(**config)


# ======================================================================
# Builder: BaseCodeExecutor
# ======================================================================

class BaseCodeExecutor(BuilderBase):
    """Abstract base class for all code executors."""

    # --- Class-level alias / field maps ---
    _ALIASES: dict[str, str] = {}
    _CALLBACK_ALIASES: dict[str, str] = {}
    _ADDITIVE_FIELDS: set[str] = set()


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Explicit field methods ---

    def optimize_data_file(self, value: bool) -> Self:
        """Set the ``optimize_data_file`` field."""
        self._config["optimize_data_file"] = value
        return self


    def stateful(self, value: bool) -> Self:
        """Set the ``stateful`` field."""
        self._config["stateful"] = value
        return self


    def error_retry_attempts(self, value: int) -> Self:
        """Set the ``error_retry_attempts`` field."""
        self._config["error_retry_attempts"] = value
        return self


    def code_block_delimiters(self, value: list[tuple[str, str]]) -> Self:
        """Set the ``code_block_delimiters`` field."""
        self._config["code_block_delimiters"] = value
        return self


    def execution_result_delimiters(self, value: tuple[str, str]) -> Self:
        """Set the ``execution_result_delimiters`` field."""
        self._config["execution_result_delimiters"] = value
        return self

    # --- Extra methods ---

    # --- Dynamic field forwarding (safety net) ---

    def __getattr__(self, name: str):
        """Forward unknown methods to _ADK_BaseCodeExecutor.model_fields for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map (class-level constants)
        _ALIASES = self.__class__._ALIASES
        _CALLBACK_ALIASES = self.__class__._CALLBACK_ALIASES
        _ADDITIVE_FIELDS = self.__class__._ADDITIVE_FIELDS

        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against actual Pydantic schema
        if field_name not in _ADK_BaseCodeExecutor.model_fields:
            available = sorted(
                set(_ADK_BaseCodeExecutor.model_fields.keys())
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized field on _ADK_BaseCodeExecutor. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> _ADK_BaseCodeExecutor:
        """Abstract base class for all code executors. Resolve into a native ADK _ADK_BaseCodeExecutor."""
        config = self._prepare_build_config()
        return _ADK_BaseCodeExecutor(**config)


# ======================================================================
# Builder: BuiltInCodeExecutor
# ======================================================================

class BuiltInCodeExecutor(BuilderBase):
    """A code executor that uses the Model's built-in code executor."""

    # --- Class-level alias / field maps ---
    _ALIASES: dict[str, str] = {}
    _CALLBACK_ALIASES: dict[str, str] = {}
    _ADDITIVE_FIELDS: set[str] = set()


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Explicit field methods ---

    def optimize_data_file(self, value: bool) -> Self:
        """Set the ``optimize_data_file`` field."""
        self._config["optimize_data_file"] = value
        return self


    def stateful(self, value: bool) -> Self:
        """Set the ``stateful`` field."""
        self._config["stateful"] = value
        return self


    def error_retry_attempts(self, value: int) -> Self:
        """Set the ``error_retry_attempts`` field."""
        self._config["error_retry_attempts"] = value
        return self


    def code_block_delimiters(self, value: list[tuple[str, str]]) -> Self:
        """Set the ``code_block_delimiters`` field."""
        self._config["code_block_delimiters"] = value
        return self


    def execution_result_delimiters(self, value: tuple[str, str]) -> Self:
        """Set the ``execution_result_delimiters`` field."""
        self._config["execution_result_delimiters"] = value
        return self

    # --- Extra methods ---

    # --- Dynamic field forwarding (safety net) ---

    def __getattr__(self, name: str):
        """Forward unknown methods to _ADK_BuiltInCodeExecutor.model_fields for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map (class-level constants)
        _ALIASES = self.__class__._ALIASES
        _CALLBACK_ALIASES = self.__class__._CALLBACK_ALIASES
        _ADDITIVE_FIELDS = self.__class__._ADDITIVE_FIELDS

        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against actual Pydantic schema
        if field_name not in _ADK_BuiltInCodeExecutor.model_fields:
            available = sorted(
                set(_ADK_BuiltInCodeExecutor.model_fields.keys())
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized field on _ADK_BuiltInCodeExecutor. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> _ADK_BuiltInCodeExecutor:
        """A code executor that uses the Model's built-in code executor. Resolve into a native ADK _ADK_BuiltInCodeExecutor."""
        config = self._prepare_build_config()
        return _ADK_BuiltInCodeExecutor(**config)


# ======================================================================
# Builder: UnsafeLocalCodeExecutor
# ======================================================================

class UnsafeLocalCodeExecutor(BuilderBase):
    """A code executor that unsafely execute code in the current local context."""

    # --- Class-level alias / field maps ---
    _ALIASES: dict[str, str] = {}
    _CALLBACK_ALIASES: dict[str, str] = {}
    _ADDITIVE_FIELDS: set[str] = set()


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Explicit field methods ---

    def optimize_data_file(self, value: bool) -> Self:
        """Set the ``optimize_data_file`` field."""
        self._config["optimize_data_file"] = value
        return self


    def stateful(self, value: bool) -> Self:
        """Set the ``stateful`` field."""
        self._config["stateful"] = value
        return self


    def error_retry_attempts(self, value: int) -> Self:
        """Set the ``error_retry_attempts`` field."""
        self._config["error_retry_attempts"] = value
        return self


    def code_block_delimiters(self, value: list[tuple[str, str]]) -> Self:
        """Set the ``code_block_delimiters`` field."""
        self._config["code_block_delimiters"] = value
        return self


    def execution_result_delimiters(self, value: tuple[str, str]) -> Self:
        """Set the ``execution_result_delimiters`` field."""
        self._config["execution_result_delimiters"] = value
        return self

    # --- Extra methods ---

    # --- Dynamic field forwarding (safety net) ---

    def __getattr__(self, name: str):
        """Forward unknown methods to _ADK_UnsafeLocalCodeExecutor.model_fields for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map (class-level constants)
        _ALIASES = self.__class__._ALIASES
        _CALLBACK_ALIASES = self.__class__._CALLBACK_ALIASES
        _ADDITIVE_FIELDS = self.__class__._ADDITIVE_FIELDS

        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against actual Pydantic schema
        if field_name not in _ADK_UnsafeLocalCodeExecutor.model_fields:
            available = sorted(
                set(_ADK_UnsafeLocalCodeExecutor.model_fields.keys())
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized field on _ADK_UnsafeLocalCodeExecutor. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> _ADK_UnsafeLocalCodeExecutor:
        """A code executor that unsafely execute code in the current local context. Resolve into a native ADK _ADK_UnsafeLocalCodeExecutor."""
        config = self._prepare_build_config()
        return _ADK_UnsafeLocalCodeExecutor(**config)


# ======================================================================
# Builder: VertexAiCodeExecutor
# ======================================================================

class VertexAiCodeExecutor(BuilderBase):
    """A code executor that uses Vertex Code Interpreter Extension to execute code."""

    # --- Class-level alias / field maps ---
    _ALIASES: dict[str, str] = {}
    _CALLBACK_ALIASES: dict[str, str] = {}
    _ADDITIVE_FIELDS: set[str] = set()


    def __init__(self, ) -> None:
        self._config: dict[str, Any] = {}
        self._callbacks: dict[str, list[Callable]] = defaultdict(list)
        self._lists: dict[str, list] = defaultdict(list)

    # --- Ergonomic aliases ---

    # --- Additive callback methods ---

    # --- Explicit field methods ---

    def optimize_data_file(self, value: Any) -> Self:
        """Set the ``optimize_data_file`` field."""
        self._config["optimize_data_file"] = value
        return self


    def stateful(self, value: Any) -> Self:
        """Set the ``stateful`` field."""
        self._config["stateful"] = value
        return self


    def error_retry_attempts(self, value: Any) -> Self:
        """Set the ``error_retry_attempts`` field."""
        self._config["error_retry_attempts"] = value
        return self


    def code_block_delimiters(self, value: Any) -> Self:
        """Set the ``code_block_delimiters`` field."""
        self._config["code_block_delimiters"] = value
        return self


    def execution_result_delimiters(self, value: Any) -> Self:
        """Set the ``execution_result_delimiters`` field."""
        self._config["execution_result_delimiters"] = value
        return self


    def resource_name(self, value: Any) -> Self:
        """Set the ``resource_name`` field."""
        self._config["resource_name"] = value
        return self

    # --- Extra methods ---

    # --- Dynamic field forwarding (safety net) ---

    def __getattr__(self, name: str):
        """Forward unknown methods to _ADK_VertexAiCodeExecutor.model_fields for zero-maintenance compatibility."""
        if name.startswith("_"):
            raise AttributeError(name)

        # Resolve through alias map (class-level constants)
        _ALIASES = self.__class__._ALIASES
        _CALLBACK_ALIASES = self.__class__._CALLBACK_ALIASES
        _ADDITIVE_FIELDS = self.__class__._ADDITIVE_FIELDS

        field_name = _ALIASES.get(name, name)

        # Check if it's a callback alias
        if name in _CALLBACK_ALIASES:
            cb_field = _CALLBACK_ALIASES[name]
            def _cb_setter(fn: Callable) -> Self:
                self._callbacks[cb_field].append(fn)
                return self
            return _cb_setter

        # Validate against actual Pydantic schema
        if field_name not in _ADK_VertexAiCodeExecutor.model_fields:
            available = sorted(
                set(_ADK_VertexAiCodeExecutor.model_fields.keys())
                | set(_ALIASES.keys())
                | set(_CALLBACK_ALIASES.keys())
            )
            raise AttributeError(
                f"'{name}' is not a recognized field on _ADK_VertexAiCodeExecutor. "
                f"Available: {', '.join(available)}"
            )

        # Return a setter that stores value and returns self for chaining
        def _setter(value: Any) -> Self:
            if field_name in _ADDITIVE_FIELDS:
                self._callbacks[field_name].append(value)
            else:
                self._config[field_name] = value
            return self

        return _setter

    # --- Terminal methods ---

    def build(self) -> _ADK_VertexAiCodeExecutor:
        """A code executor that uses Vertex Code Interpreter Extension to execute code. Resolve into a native ADK _ADK_VertexAiCodeExecutor."""
        config = self._prepare_build_config()
        return _ADK_VertexAiCodeExecutor(**config)
